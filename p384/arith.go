package p384

import (
	"github.com/cloudflare/circl/utils"
	"github.com/cloudflare/circl/utils/cpu"
	"math/big"
)

var hasBMI2 = cpu.X86.HasBMI2

const sizeFp = 48

type fp384 [sizeFp]byte

func fp384Set(b *big.Int) *fp384 {
	var ret fp384
	if b.BitLen() > 384 || b.Sign() < 0 {
		b = new(big.Int).Mod(b, p.BigInt())
	}
	copy(ret[:], utils.BigInt2Num(b, sizeFp))
	return &ret
}

func (e fp384) BigInt() *big.Int { return utils.Num2BigInt(e[:]) }
func (e fp384) String() string   { return utils.Num2Hex(e[:]) }

func fp384Inv(z, x *fp384) {
	y := r
	for B := sizeFp - 1; B >= 0; B-- {
		for b := 7; b >= 0; b-- {
			fp384Sqr(&y, &y)
			if (pm2[B]>>uint(b))&1 == 1 {
				fp384Mul(&y, &y, x)
			}
		}
	}
	*z = y
}

func montEncode(c, a *fp384) { fp384Mul(c, a, &r2) }
func montDecode(c, a *fp384) { fp384Mul(c, a, &fp384{1}) }
func fp384Sqr(c, a *fp384)   { fp384Mul(c, a, a) }

// go:noescape
func fp384Neg(c, a *fp384)

//go:noescape
func fp384Add(c, a, b *fp384)

//go:noescape
func fp384Sub(c, a, b *fp384)

//go:noescape
func fp384Mul(c, a, b *fp384)

var (
	// p is the order of the base field, represented as little-endian 64-bit words.
	p = fp384{
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}
	// pm2 is p-2, the expoenent to get an inverse mod p
	pm2 = fp384{
		0xfd, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	// pp satisfies r*rp - p*pp = 1 where rp and pp are both integers.
	pp = fp384{
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff,
		0xfa, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
		0x0c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
	}

	// r is R where R = 2^384 mod p.
	r = fp384{
		0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	// r2 is R^2 where R = 2^384 mod p.
	r2 = fp384{
		0x01, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	// r3 is R^3 where R = 2^384 mod p.
	r3 = fp384{
		0x02, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff,
		0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xfd, 0xff, 0xff, 0xff,
		0xfd, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	}
	// rN1 is R^-1 where R = 2^384 mod p.
	rN1 = fp384{
		0x06, 0x00, 0x00, 0x00, 0xe1, 0xff, 0xff, 0xff, 0xd8, 0xff, 0xff, 0xff,
		0xeb, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff,
		0xfa, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
		0x0c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
	}
)
