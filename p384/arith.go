package p384

import (
	"github.com/cloudflare/circl/utils"
	"github.com/cloudflare/circl/utils/cpu"
	"math/big"
)

var hasBMI2 = cpu.X86.HasBMI2

const sizeFp = 48

type fp384 [sizeFp]byte

func fp384Set(b *big.Int) *fp384 {
	var ret fp384
	if b.BitLen() > 384 || b.Sign() < 0 {
		b = new(big.Int).Mod(b, p.BigInt())
	}
	copy(ret[:], utils.BigInt2Num(b, sizeFp))
	return &ret
}

func (e fp384) BigInt() *big.Int { return utils.Num2BigInt(e[:]) }
func (e fp384) String() string   { return utils.Num2Hex(e[:]) }

func fp384Inv(z, x *fp384) {
	t0, t1, t2, t3, t4 := &fp384{}, &fp384{}, &fp384{}, &fp384{}, &fp384{}
	/* alpha_1 */
	fp384Sqr(t4, x)
	/* alpha_2 */
	fp384Mul(t4, t4, x)

	/* alpha_3 */
	fp384Sqr(t0, t4)
	fp384Mul(t0, t0, x)

	/* alpha_6 */
	fp384Sqr(t1, t0)
	fp384Sqr(t1, t1)
	fp384Sqr(t1, t1)
	fp384Mul(t1, t1, t0)

	/* alpha_12 */
	fp384Sqr(t2, t1)
	for i := 0; i < 5; i++ {
		fp384Sqr(t2, t2)
	}
	fp384Mul(t2, t2, t1)

	/* alpha_15 */
	for i := 0; i < 3; i++ {
		fp384Sqr(t2, t2)
	}
	fp384Mul(t2, t2, t0)

	/* alpha_30 */
	fp384Sqr(t1, t2)
	for i := 0; i < 14; i++ {
		fp384Sqr(t1, t1)
	}
	fp384Mul(t1, t1, t2)

	/* alpha_60 */
	fp384Sqr(t3, t1)
	for i := 0; i < 29; i++ {
		fp384Sqr(t3, t3)
	}
	fp384Mul(t3, t3, t1)

	/* T_3 = alpha_30^(2^2) */
	fp384Sqr(t1, t1)
	fp384Sqr(t1, t1)

	/* alpha_32 */
	*t0 = *t1
	fp384Mul(t0, t0, t4)

	/* T_3 = a^(2^32-3) = (alpha_30)^(2^2)*alpha_1 */
	fp384Mul(t1, t1, x)

	/* alpha_120 */
	fp384Sqr(t4, t3)
	for i := 0; i < 59; i++ {
		fp384Sqr(t4, t4)
	}
	fp384Mul(t4, t4, t3)

	/* alpha_240 */
	fp384Sqr(t3, t4)
	for i := 0; i < 119; i++ {
		fp384Sqr(t3, t3)
	}
	fp384Mul(t3, t3, t4)

	/* alpha_255 */
	for i := 0; i < 15; i++ {
		fp384Sqr(t3, t3)
	}
	fp384Mul(t3, t3, t2)

	/* T_5 = a^(2^288-2^32-1) = (alpha_255)^(2^33)*alpha_32 */
	for i := 0; i < 33; i++ {
		fp384Sqr(t3, t3)
	}
	fp384Mul(t3, t3, t0)

	/* T_1 = a^(2^384-2^128-2^96+2^32-3) = (T_1)^(2^96)*T_3 */
	fp384Sqr(t4, t3)
	for i := 0; i < 95; i++ {
		fp384Sqr(t4, t4)
	}
	fp384Mul(z, t4, t1)
}

func montEncode(c, a *fp384) { fp384Mul(c, a, &r2) }
func montDecode(c, a *fp384) { fp384Mul(c, a, &fp384{1}) }
func fp384Sqr(c, a *fp384)   { fp384Mul(c, a, a) }

// go:noescape
func fp384Neg(c, a *fp384)

//go:noescape
func fp384Add(c, a, b *fp384)

//go:noescape
func fp384Sub(c, a, b *fp384)

//go:noescape
func fp384Mul(c, a, b *fp384)

var (
	// p is the order of the base field, represented as little-endian 64-bit words.
	p = fp384{
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}
	// pm2 is p-2, the expoenent to get an inverse mod p
	pm2 = fp384{
		0xfd, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	// pp satisfies r*rp - p*pp = 1 where rp and pp are both integers.
	pp = fp384{
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff,
		0xfa, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
		0x0c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
	}

	// r is R where R = 2^384 mod p.
	r = fp384{
		0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	// r2 is R^2 where R = 2^384 mod p.
	r2 = fp384{
		0x01, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	// r3 is R^3 where R = 2^384 mod p.
	r3 = fp384{
		0x02, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff,
		0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xfd, 0xff, 0xff, 0xff,
		0xfd, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	}
	// rN1 is R^-1 where R = 2^384 mod p.
	rN1 = fp384{
		0x06, 0x00, 0x00, 0x00, 0xe1, 0xff, 0xff, 0xff, 0xd8, 0xff, 0xff, 0xff,
		0xeb, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff,
		0xfa, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
		0x0c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
	}
)
