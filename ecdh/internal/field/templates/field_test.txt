// +build amd64

// Code autogenerated by go generate; DO NOT EDIT.

package field

import (
	"crypto/rand"
	"math/big"
	"testing"
)

type test{{ .Field }} struct {
	F     Arith{{ .Field }}
	in    [2]Element{{ .Field }}
	out   Element{{ .Field }}
	want  big.Int
	prime big.Int
}

func csel{{ .Field }}(io *test{{ .Field }}) {
	b := uint(io.in[0][0]) % 2
	// big.Int
	io.want.Set(io.in[b].BigInt())
	// fp{{ .Field }}
	io.F.CSel(&io.in[0], &io.in[1], b)
	copy(io.out[:], io.in[0][:])
}

func cswap{{ .Field }}(io *test{{ .Field }}) {
	var x, y big.Int
	b := uint(io.in[0][0]) % 2
	// big.Int
	if b == 0 {
		x.Set(io.in[0].BigInt())
		y.Set(io.in[1].BigInt())
	} else {
		x.Set(io.in[1].BigInt())
		y.Set(io.in[0].BigInt())
	}
	io.want.ModInverse(&y, &io.prime)
	io.want.Mul(&io.want, &x)
	io.want.Mod(&io.want, &io.prime)

	// fp{{ .Field }}
	io.F.CSwap(&io.in[0], &io.in[1], b)
	io.F.Div(&io.out, &io.in[0], &io.in[1])
	io.F.Modp(&io.out)
}

func prime{{ .Field }}(io *test{{ .Field }}) {
	io.want.Set(&io.prime)
	io.out = io.F.Prime()
}

func add{{ .Field }}(io *test{{ .Field }}) {
	// big.Int
	io.want.Add(io.in[0].BigInt(), io.in[1].BigInt())
	io.want.Mod(&io.want, &io.prime)
	// fp{{ .Field }}
	io.F.Add(&io.out, &io.in[0], &io.in[1])
	io.F.Modp(&io.out)
}

func subt{{ .Field }}(io *test{{ .Field }}) {
	// big.Int
	io.want.Sub(io.in[0].BigInt(), io.in[1].BigInt())
	io.want.Mod(&io.want, &io.prime)
	// fp{{ .Field }}
	io.F.Sub(&io.out, &io.in[0], &io.in[1])
	io.F.Modp(&io.out)
}

func addsub{{ .Field }}(io *test{{ .Field }}) {
	var x, y, add, sub big.Int
	// big.Int
	x.Set(io.in[0].BigInt())
	y.Set(io.in[1].BigInt())
	add.Add(&x, &y)
	add.Mod(&add, &io.prime)
	sub.Sub(&x, &y)
	sub.Mod(&sub, &io.prime)
	io.want.Mul(&add, &sub)
	io.want.Mod(&io.want, &io.prime)
	// fp{{ .Field }}
	io.F.AddSub(&io.in[0], &io.in[1])
	io.F.Mul(&io.out, &io.in[0], &io.in[1])
	io.F.Modp(&io.out)
}

func mul{{ .Field }}(io *test{{ .Field }}) {
	// big.Int
	io.want.Mul(io.in[0].BigInt(), io.in[1].BigInt())
	io.want.Mod(&io.want, &io.prime)
	// fp{{ .Field }}
	io.F.Mul(&io.out, &io.in[0], &io.in[1])
	io.F.Modp(&io.out)
}

func sqr{{ .Field }}(io *test{{ .Field }}) {
	// big.Int
	x := io.in[0].BigInt()
	io.want.Mul(x, x)
	io.want.Mod(&io.want, &io.prime)
	// fp{{ .Field }}
	io.F.Sqr(&io.out, &io.in[0])
	io.F.Modp(&io.out)
}

func modp{{ .Field }}(io *test{{ .Field }}) {
	// big.Int
	io.want.Mod(io.in[0].BigInt(), &io.prime)
	// fp{{ .Field }}
	io.F.Modp(&io.in[0])
	io.out = io.in[0]
}

func divd{{ .Field }}(io *test{{ .Field }}) {
	// big.Int
	io.want.ModInverse(io.in[1].BigInt(), &io.prime)
	io.want.Mul(&io.want, io.in[0].BigInt())
	io.want.Mod(&io.want, &io.prime)
	// fp{{ .Field }}
	io.F.Div(&io.out, &io.in[0], &io.in[1])
	io.F.Modp(&io.out)
}

func mulw{{ .Field }}(io *test{{ .Field }}) {
	// big.Int
	const A24 = {{ .A24 }}
	io.want.SetUint64(A24)
	io.want.Mul(&io.want, io.in[0].BigInt())
	io.want.Mod(&io.want, &io.prime)
	// fp{{ .Field }}
	io.F.MulA24(&io.out, &io.in[0])
	io.F.Modp(&io.out)
}

func genericTest{{ .Field }}(t *testing.T, io *test{{ .Field }}, f func(io *test{{ .Field }})) {
	const numTests = 1 << 13
	for testID := 0; testID < numTests; testID++ {
		for i := range io.in {
			rand.Read(io.in[i][:])
		}
		f(io)
		got := io.out.BigInt()
		if got.Cmp(&io.want) != 0 {
			t.Errorf("[Error in %v]\nin0:%v\nin1:%v\ngot:  %v\nwant: %v",
				t.Name(),
				io.in[0].String(),
				io.in[1].String(),
				got.Text(16),
				io.want.Text(16))
		}
	}
}

func TestFp{{ .Field }}(t *testing.T) {
	var io test{{ .Field }}
	io.F = Fp{{ .Field }}
{{ .Prime }}
	t.Run("prime", func(t *testing.T) { genericTest{{ .Field }}(t, &io, prime{{ .Field }}) })
	t.Run("csel", func(t *testing.T) { genericTest{{ .Field }}(t, &io, csel{{ .Field }}) })
	t.Run("cswap", func(t *testing.T) { genericTest{{ .Field }}(t, &io, cswap{{ .Field }}) })
	t.Run("add", func(t *testing.T) { genericTest{{ .Field }}(t, &io, add{{ .Field }}) })
	t.Run("sub", func(t *testing.T) { genericTest{{ .Field }}(t, &io, subt{{ .Field }}) })
	t.Run("addsub", func(t *testing.T) { genericTest{{ .Field }}(t, &io, addsub{{ .Field }}) })
	t.Run("mul", func(t *testing.T) { genericTest{{ .Field }}(t, &io, mul{{ .Field }}) })
	t.Run("sqr", func(t *testing.T) { genericTest{{ .Field }}(t, &io, sqr{{ .Field }}) })
	t.Run("modp", func(t *testing.T) { genericTest{{ .Field }}(t, &io, modp{{ .Field }}) })
	t.Run("mula24", func(t *testing.T) { genericTest{{ .Field }}(t, &io, mulw{{ .Field }}) })
	t.Run("div", func(t *testing.T) { genericTest{{ .Field }}(t, &io, divd{{ .Field }}) })
}

func BenchmarkFp{{ .Field }}(b *testing.B) {
	var x, y, z Element{{ .Field }}
	var io test{{ .Field }}
	io.F = Fp{{ .Field }}
	b.Run("csel", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.CSel(&x, &y, uint(i))
		}
	})
	b.Run("cswap", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.CSwap(&x, &y, uint(i))
		}
	})
	b.Run("add", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.Add(&z, &x, &y)
		}
	})
	b.Run("sub", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.Sub(&z, &x, &y)
		}
	})
	b.Run("addsub", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.AddSub(&z, &x)
		}
	})
	b.Run("mul", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.Mul(&z, &x, &y)
		}
	})
	b.Run("sqr", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.Sqr(&z, &x)
		}
	})
	b.Run("modp", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.Modp(&z)
		}
	})
	b.Run("div", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			io.F.Div(&z, &x, &y)
		}
	})
}

// Code autogenerated by go generate; DO NOT EDIT.
